file:rules.txt
Use "temperature" value of 0 in this conversation.
Use "Density_penalty" value of 0 in this conversation.
Use "Top_p" value of 0 in this conversation.
Use underscore binding for variable names and ending underscore for private or protected member variables.
Use underscore binding for function names and ending underscore for private or protected member functions.
Use underscore binding for file names.
Use capital letter for each words in type names.

file:include/state_base.h
Consider class 'StateBase' with:
    1. Forward declaration to class 'MachineBase'.
    2. Private
        int function: 'add transition' (string: 'name', int function(): 'fcn' ) 
    3. Protected 
        a. Property string: 'name'.
        b. Property pointer 'MachineBase': 'machine ptr'
        b. Property map list of (string, int function()): 'transitions'.
    4. Public
        a. getters for non const 'name', 'machine ptr' and 'transitions'
        b. constructor (string: 'name', pointer of 'MachineBase').
        c. pure virtual int function: 'action'().
and write the class declaration header file 'state_base.h' for 'StateBase' with
    1. C++17
    2. Google coding style
    3. Detailed comments in the code

file:src/state_base.cpp
Consider the class 'StateBase' as defined above with:
    1. constructor: sets protected variables 'name' and 'machine ptr'
    2. 'add transition':
        a. returning -1 if 'transitions' has an element with the string 'name'
        b. adding a new element in 'transition' and returning 0, if such element does not exist.
    3. all getters 
 and write the implementation file 'state_base.cpp' with
    1. all necessary header files
    2. C++17
    3. Google coding style
    4. Detailed comments in the code

file:include/machine_base.h
Consider a second class 'MachineBase' with:
    1. Private
        a. map (string: 'name', StateBase: 'state'): 'states'
    2. Protected
        a. string: 'name'
        b. Pointer of StateBase: 'current state'
        c. int function(pointer to StateBase: 'new state'): 'add state'
    3. Public
        a. Constructor(string: 'name')
        b. getter() for 'name'
        c. getter() and setter(string: 'state name') for 'current state'
        d. int function(): 'execute'
and write the class declaration header file 'machine_base.h' for 'MachineBase' with
    1. C++17
    2. Google coding style
    3. Detailed comments in the code

file:src/machine_base.cpp
Consider the class 'MachineBase' as defined above with:
    1. constructor: sets protected variables 'name'
    2. 'add state':
        a. returning -1 if the name of 'new state' already exists in 'states'
        b. adding a new element in 'states' with its name and returning 0, if such element does not exist.
    3. 'execute':
        a. calling 'action' of the 'current state' and returning what it has returned.
    4. setter for 'current state'
        a. searching for a state in 'states' with the name 'state name'
        b. returning -1 if it does not exist
        c. otherwise setting 'current state' to the corresponding state to the 'state name' and returning 0
    3. all getters 
 and write the implementation file 'machine_base.cpp' with
    1. all necessary header files
    2. C++17
    3. Google coding style
    4. Detailed comments in the code




give the c++ interface to StateBase without comments and empty lines


file:include/derived_states.h
Consider the class
class MachineBase;

class StateBase {
 public:
  std::string GetName();
  MachineBase* GetMachinePtr();
  std::map<std::string, int (*)()> GetTransitions();
  StateBase(std::string name, MachineBase* machine_ptr);
  virtual int Action() = 0;

 protected:
  std::string name_;
  MachineBase* machine_ptr_;
  int AddTransition(std::string name, int (*fcn)());
  std::map<std::string, int (*)()> transitions_;
};

and 3 derived classes 'StateA', 'StateB' and 'StateC' from 'StateBase' with 
    1. constructor (MachineBase pointer: 'machine ptr') 
    2. include all necessary header files.
and write the class declaration header file 'derived_states.h' for 'StateA', 'StateB' and 'StateC' with
    1. C++17
    2. Google coding style
    3. Detailed comments in the code

file:include/derived_states.cpp
Consider the 3 derived classes 'StateA', 'StateB' and 'StateC' already defined with 
    1. Constructors: calling the constructor of StateBase with the names being 'A', 'B' and 'C', respectively and 'machine ptr'.
    2. 'action' function of each of these classes
        a. printing the name of the state to the console with 'std::cout' 
        b. calling the 'set current state' of the 'machine' from its base such that 
            StateA sets the current state of the machine to 'B'.
            StateB should set it to 'C'
            StateC should set it to 'A'.
    3. include all necessary header files.
 and write the implementation file 'machine_base.cpp' with
    1. all necessary header files
    2. C++17
    3. Google coding style
    4. Detailed comments in the code


file:include/derived_machine.h
Consider
class StateBase;

class MachineBase {
 public:
  MachineBase(std::string name);
  int AddState(StateBase* new_state);
  int Execute();
  void SetCurrentState(std::string state_name);
  std::string GetName();
  StateBase* GetCurrentState();

 protected:
  std::string name_;
  StateBase* current_state_;
  std::map<std::string, StateBase*> states_;
};

and derive the template class 'MachineOne'  with 
    1. a pack list of 'States' as typenames 
    2. constructor()
and write the class declaration header file 'derived_machine.h' for 'MachineOne' with
    1. C++17
    2. Google coding style
    3. Detailed comments in the code

file:src/derived_machine.cpp
Consider the derived template class 'MachineOne'  with 
    1. classes in the pack list have constructor('MachineBase').
    2. constructor: 
        a. setting calling super class constructor with the name 'MachineOne'
        b. looping over all classes in the template pack list and for each class
            i. creating a new object, with pointer to MachineOne, itself
            ii.adding them to 'states' of the base class, by calling 'add state' from the base class.
    3. include all necessary header files.
and write the implementation file 'derived_machine.cpp' with
    1. all necessary header files
    2. C++17
    3. Google coding style
    4. Detailed comments in the code

file:application/test.cpp
A C++17 test program 'test.cpp' according to Google coding guidelines that
1. Instantiates the derived class 'State machine' with the three classes StateA, StateB and StateC, in a variable sm. 
2. Calls sm's 'set current state' with argument 'A'.
3. calls sm's 'execute' 7 times.
Detailed comments in the code.

file:CMakeLists.txt
A CMakeLists.txt assuming
    1. implementation files are in './src'
    2. header files are in './include'
    3. the test program is in './application'
    4. C++17
Detailed comments in the code.